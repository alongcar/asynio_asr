import queue
import json
import base64
from vosk import Model, KaldiRecognizer


class SpeechRecognizer:
    def __init__(self, model_path, sample_rate=16000):
        """
        初始化语音识别器 - 支持多客户端单播模式
        Args:
            model_path: Vosk模型路径
            sample_rate: 采样率
        """
        try:
            self.model = Model(model_path)
            self.sample_rate = sample_rate

            # 为每个客户端维护独立的识别器状态
            self.client_recognizers = {}  # client_id -> KaldiRecognizer
            self.audio_queues = {}  # client_id -> queue.Queue()
            self.is_listening = False
            self.partial_results = {}  # 存储每个客户端的部分识别结果

        except Exception as e:
            raise Exception(f"模型加载失败: {e}")

    def put_audio_data(self, audio_data, client_id=None):
        """
        接收前端发来的音频数据，支持客户端ID区分
        Args:
            audio_data: 可以是base64字符串或二进制数据
            client_id: 客户端标识，为None时使用默认识别器（向后兼容）
        """
        if client_id is None:
            client_id = "default"

        if isinstance(audio_data, str):
            # 如果是base64字符串，解码为二进制
            try:
                audio_data = base64.b64decode(audio_data)
            except Exception as e:
                print(f"Base64解码失败: {e}")
                return False

        # 确保该客户端的队列存在
        if client_id not in self.audio_queues:
            self.audio_queues[client_id] = queue.Queue()
            self.partial_results[client_id] = ""

            # 为该客户端创建独立的识别器
            self.client_recognizers[client_id] = KaldiRecognizer(self.model, self.sample_rate)
            self.client_recognizers[client_id].SetWords(True)

        # 将音频数据放入对应客户端的队列
        try:
            self.audio_queues[client_id].put(audio_data)
            return True
        except Exception as e:
            print(f"音频数据入队失败: {e}")
            return False

    def start_listening(self):
        """开始处理多客户端音频流（生成器模式）"""
        self.is_listening = True
        print("开始处理多客户端音频流...")

        while self.is_listening:
            try:
                # 检查所有客户端的队列
                for client_id, audio_queue in list(self.audio_queues.items()):
                    try:
                        # 非阻塞方式获取音频数据
                        data = audio_queue.get_nowait()
                        # print("识别data:", data)

                        # 获取对应客户端的识别器
                        recognizer = self.client_recognizers.get(client_id)
                        if not recognizer:
                            continue

                        # 处理音频数据
                        if recognizer.AcceptWaveform(data):
                            result = json.loads(recognizer.Result())
                            text = result.get("text", "").strip()

                            if text:
                                yield {
                                    "client_id": client_id,  # 新增：返回客户端ID
                                    "type": "final",
                                    "text": text,
                                    "result": result
                                }
                        else:
                            partial_result = json.loads(recognizer.PartialResult())
                            partial_text = partial_result.get("partial", "")

                            # 只有当部分结果发生变化时才返回
                            if partial_text and partial_text != self.partial_results.get(client_id, ""):
                                self.partial_results[client_id] = partial_text
                                yield {
                                    "client_id": client_id,  # 新增：返回客户端ID
                                    "type": "partial",
                                    "text": partial_text
                                }

                    except queue.Empty:
                        # 该客户端队列为空，继续检查下一个客户端
                        continue
                    except Exception as e:
                        print(f"客户端 {client_id} 音频处理错误: {e}")
                        continue

                # 短暂休眠避免CPU占用过高
                import time
                time.sleep(0.01)

            except Exception as e:
                print(f"监听循环错误: {e}")
                continue

    def start_listening_with_client_id(self):
        """兼容新方法名，与单播控制器保持一致"""
        return self.start_listening()

    def remove_client(self, client_id):
        """移除指定客户端的识别器和队列"""
        if client_id in self.audio_queues:
            # 清空队列
            while not self.audio_queues[client_id].empty():
                try:
                    self.audio_queues[client_id].get_nowait()
                except queue.Empty:
                    break
            del self.audio_queues[client_id]

        if client_id in self.client_recognizers:
            del self.client_recognizers[client_id]

        if client_id in self.partial_results:
            del self.partial_results[client_id]

        print(f"已移除客户端 {client_id} 的语音识别资源")

    def stop_listening(self):
        """停止所有客户端的语音识别"""
        self.is_listening = False

        # 清空所有队列
        for client_id in list(self.audio_queues.keys()):
            self.remove_client(client_id)

        print("语音识别服务已停止")

    def get_client_count(self):
        """获取当前活跃的客户端数量"""
        return len(self.audio_queues)

    def has_audio_data(self, client_id):
        """检查指定客户端是否有待处理的音频数据"""
        if client_id in self.audio_queues:
            return not self.audio_queues[client_id].empty()
        return False